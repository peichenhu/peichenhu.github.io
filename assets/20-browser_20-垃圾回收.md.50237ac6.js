import{_ as e,c as a,o,Q as c}from"./chunks/framework.03c6a765.js";const q=JSON.parse('{"title":"垃圾回收 GC","description":"","frontmatter":{},"headers":[],"relativePath":"20-browser/20-垃圾回收.md","filePath":"20-browser/20-垃圾回收.md","lastUpdated":1703663478000}'),l={name:"20-browser/20-垃圾回收.md"},r=c('<h1 id="垃圾回收-gc" tabindex="-1">垃圾回收 GC <a class="header-anchor" href="#垃圾回收-gc" aria-label="Permalink to &quot;垃圾回收 GC&quot;">​</a></h1><h2 id="内存空间" tabindex="-1">内存空间 <a class="header-anchor" href="#内存空间" aria-label="Permalink to &quot;内存空间&quot;">​</a></h2><p>JS 引擎的内存空间主要分为<code>栈内存</code>和<code>堆内存</code>，在创建数据时会自动进行了分配内存，并且在不使用它们时 <code>自动释放内存</code>。</p><h3 id="栈内存" tabindex="-1">栈内存 <a class="header-anchor" href="#栈内存" aria-label="Permalink to &quot;栈内存&quot;">​</a></h3><p>栈是轻量的临时存储空间，主要存储局部变量和函数调用。</p><ol><li><p><code>基本类型数据</code>保存在栈内存。</p></li><li><p><code>引用类型数据的变量指针</code>：引用类型数据保存在堆内存中，但指向它的变量指针数据保存在栈内存。</p></li><li><p><code>函数调用栈</code>，解释器创建了<strong>调用栈</strong>来记录函数的调用过程。</p><p>每调用一个函数，解释器就可以把该函数添加进调用栈， 解释器会为被添加进来的函数创建一个栈帧（用来保存函数的局部变量以及执行语句）并立即执行。 如果正在执行的函数还调用了其他函数，新函数会继续被添加进入调用栈。 函数执行完成，对应的栈帧立即被销毁。</p><p>查看调用栈: 使用浏览器开发者工具进行 <code>断点调试</code>或者使用 <code>console.trace()</code> 向 Web 控制台输出一个堆栈跟踪.</p></li></ol><h3 id="堆内存" tabindex="-1">堆内存 <a class="header-anchor" href="#堆内存" aria-label="Permalink to &quot;堆内存&quot;">​</a></h3><p>堆内存的数据比较复杂，大致划分为 5 个区域：</p><ul><li><code>代码区 CodeSpace</code>：这是即时编译器（JIT）存储已经编译的代码块的地方。这是唯一可执行内存的空间（尽管代码可能被分配到大型对象空间（Large object space），那也是可以执行的）。</li><li><code>单元空间 CellSpace、属性单元空间 PropertyCellSpace、映射空间 Map Space</code>：分别存放 Cell，PropertyCell 和 Map。它们包含的对象大小相同且类型有限制，可以简化回收工作。</li><li><code>大对象区 LargeObjectSpace</code>：大于其他空间大小限制的对象存放在这里。每个对象都有自己的内存区域，这里的对象不会被垃圾回收器移动。</li><li><code>新生代 NewSpace</code>： 新对象存活的地方，这些对象的生命周期都很短。</li><li><code>老生代 OldSpace</code>： 老生代内存是常驻内存，存活时间长</li></ul><h3 id="js-为什么要使用栈和堆" tabindex="-1">JS 为什么要使用栈和堆? <a class="header-anchor" href="#js-为什么要使用栈和堆" aria-label="Permalink to &quot;JS 为什么要使用栈和堆?&quot;">​</a></h3><p>JS 引擎需要用栈来维护程序执行期间的上下文的状态，如果栈空间大了的话，所有数据都存放在栈空间里面，会影响到上下文切换的效率，进而影响整个程序的执行效率。</p><h2 id="存活对象" tabindex="-1">存活对象 <a class="header-anchor" href="#存活对象" aria-label="Permalink to &quot;存活对象&quot;">​</a></h2><p>识别存活内存对象（JS 对象、作用域等）的机制：<code>引用计数</code>和<code>可达性分析</code>等。</p><h3 id="一、引用计数" tabindex="-1">一、引用计数 <a class="header-anchor" href="#一、引用计数" aria-label="Permalink to &quot;一、引用计数&quot;">​</a></h3><p>一个对象有访问另一个对象的权限（隐式或者显式）就是存活对象。</p><blockquote><p>例如：一个 JS 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p></blockquote><h3 id="二、可达性" tabindex="-1">二、可达性 <a class="header-anchor" href="#二、可达性" aria-label="Permalink to &quot;二、可达性&quot;">​</a></h3><p>找出所有的根引用 (全局变量等)，一个对象能从根引用上被直接或间接访问到就是存活对象，</p><h2 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h2><p>在创建变量时<code>自动分配内存</code>，并且在不使用它们时 <code>自动释放内存</code>，内存管理的过程称为<code>垃圾回收</code>。</p><h3 id="引用计数算法" tabindex="-1">引用计数算法 <a class="header-anchor" href="#引用计数算法" aria-label="Permalink to &quot;引用计数算法&quot;">​</a></h3><p>使用引用计数查找非存活对象（没有引用指向该对象），对象将被垃圾回收机制回收。</p><blockquote><p>🐞 缺陷是无法处理循环引用的对象</p></blockquote><h3 id="标记-清除算法" tabindex="-1">标记-清除算法 <a class="header-anchor" href="#标记-清除算法" aria-label="Permalink to &quot;标记-清除算法&quot;">​</a></h3><p>使用可达性分析查找存活对象，然后清除所有非存活内存对象。</p><blockquote><p>🐞 缺陷是无法从根对象查询到的对象都将被清除</p></blockquote><h3 id="复制算法" tabindex="-1">复制算法 <a class="header-anchor" href="#复制算法" aria-label="Permalink to &quot;复制算法&quot;">​</a></h3><ol><li>把内存分为两部分： FromSpace 和 ToSpace，新数据先在 FromSpace 进行分配；</li><li>当 FromSpace 被占满，GC 将标记并复制存活对象到 ToSpace（内存整理，避免碎片产生）；</li><li>复制完成后清空 FromSpace，将 FromSpace 和 ToSpace 进行角色互换。</li></ol><blockquote><p>🐞 缺陷是活动内存空间只能使用一半</p></blockquote><h3 id="v8-内存管理" tabindex="-1">V8 内存管理 <a class="header-anchor" href="#v8-内存管理" aria-label="Permalink to &quot;V8 内存管理&quot;">​</a></h3><p>现代垃圾回收算法是 <code>根据对象的存活时间将内存垃圾进行分代实行不同的回收算法</code>。</p><ul><li><code>新生代内存中的对象</code>存活时间较短</li><li><code>老生代内存中代对象</code>存活时间较长或是常驻内存</li></ul><h4 id="新生代内存回收" tabindex="-1"><code>新生代内存回收</code> <a class="header-anchor" href="#新生代内存回收" aria-label="Permalink to &quot;`新生代内存回收`&quot;">​</a></h4><p>新生代是指刚刚被创建的 JS 对象, 采用 Scavenge 算法（复制-晋升）。 使用 <a href="#复制算法">复制算法</a> 进行内存管理。 但当一个对象多次复制后依然处于存活状态，则认为其是<code>长期存活对象</code>， 此时将发生<code>晋升</code>，将该对象移动到<code>老生代内存</code>中，采用新的算法进行管理。</p><ul><li>晋升条件：一个对象多次复制后依然处于存活状态</li><li>晋升条件：ToSpace 的内存使用占比超过限制</li></ul><h4 id="老生代内存回收" tabindex="-1"><code>老生代内存回收</code> <a class="header-anchor" href="#老生代内存回收" aria-label="Permalink to &quot;`老生代内存回收`&quot;">​</a></h4><p>老生代内存中非存活对象占少数，内存回收采用的是<code>标记清除</code>和<code>标记整理</code>结合的方式。</p><ul><li><p><code>标记-清除算法（Mark-Sweep）</code></p><p>遍历所有的对象并标记存活对象，在标记完成后清除所有未标记的对象。</p><blockquote><p>🐞 遍历操作性能较低，清除操作导致堆内存碎片化。</p></blockquote></li><li><p><code>标记-整理算法（Mark-Compact）</code></p><p>同样会先遍历所有的对象并标记存活对象， 然后将所有存活的对象整理移动到内存空间的一端，并清空移动后的另一端的内存空间。</p><blockquote><p>🐞 整理解决堆内存碎片化的问题，整理过程的性能比<code>标记-清除算法</code>要低, 造成应用执行全暂停。</p></blockquote></li></ul><h4 id="优化-gc-的全暂停时间" tabindex="-1">优化 GC 的全暂停时间 <a class="header-anchor" href="#优化-gc-的全暂停时间" aria-label="Permalink to &quot;优化 GC 的全暂停时间&quot;">​</a></h4><p>新生代内存的垃圾回收对应用执行影响不大，但是老生代内存由于存活对象较多，造成的全停顿影响非常大。</p><p>垃圾回收时需要暂停应用执行逻辑，待垃圾回收机制结束后再恢复应用执行逻辑，该行为称为 <code>全暂停 STW</code>。</p><p>V8 为了优化 GC 的全暂停时间，还引入了增量标记、并发标记、并行标记、增量整理、并行清理、延迟清理等方式。</p><ul><li><code>并行GC</code>是开多个辅助线程分担 GC 的事情</li><li><code>增量GC</code>是将 GC 工作进行拆分，并在主线程中间歇的分步执行。</li><li><code>并发GC</code>是指 GC 在后台运行，不再在主线程运行。该做法会避免 STW 现象。</li><li><code>空闲GC</code>是指 Chrome 中动画的渲染大约是 60 帧（每帧约 16ms），如果当前渲染所花费时间每达到 16.6ms，此时则有空闲时间做其他事情。</li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7091088855457071135" target="_blank" rel="noreferrer">浅谈 V8 引擎内存管理与垃圾回收算法</a></li><li><a href="https://juejin.cn/post/7214015604534116413" target="_blank" rel="noreferrer">深入探究 V8 的内存管理技术</a></li></ul>',45),d=[r];function t(i,p,h,n,s,u){return o(),a("div",null,d)}const k=e(l,[["render",t]]);export{q as __pageData,k as default};
