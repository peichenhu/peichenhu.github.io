import{_ as s,c as n,o as a,Q as l}from"./chunks/framework.03c6a765.js";const D=JSON.parse('{"title":"vue-3-diff","description":"","frontmatter":{},"headers":[],"relativePath":"35-vue/65-vue-3-diff.md","filePath":"35-vue/65-vue-3-diff.md","lastUpdated":1703663478000}'),p={name:"35-vue/65-vue-3-diff.md"},o=l(`<h1 id="vue-3-diff" tabindex="-1">vue-3-diff <a class="header-anchor" href="#vue-3-diff" aria-label="Permalink to &quot;vue-3-diff&quot;">​</a></h1><blockquote><p>分析文件：vue@3.3.8/core/packages/runtime-core/src/renderer.ts</p></blockquote><h2 id="两个节点是否可复用判断" tabindex="-1">两个节点是否可复用判断 <a class="header-anchor" href="#两个节点是否可复用判断" aria-label="Permalink to &quot;两个节点是否可复用判断&quot;">​</a></h2><details class="details custom-block"><summary>isSameVNodeType</summary><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isSameVNodeType</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n1</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">n2</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">boolean</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n1.type </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> n2.type </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> n1.key </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> n2.key;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isSameVNodeType</span><span style="color:#24292E;">(</span><span style="color:#E36209;">n1</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">, </span><span style="color:#E36209;">n2</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">boolean</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> n1.type </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> n2.type </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> n1.key </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> n2.key;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></details><h2 id="无-key-子序列-diff" tabindex="-1">无 key 子序列 diff <a class="header-anchor" href="#无-key-子序列-diff" aria-label="Permalink to &quot;无 key 子序列 diff&quot;">​</a></h2><details class="details custom-block"><summary>patchUnkeyedChildren</summary><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 伪代码</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">patchUnkeyedChildren</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">oldCh</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">newCh</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">rest</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    oldCh </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> oldCh </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">    newCh </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newCh </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">commonLength</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">min</span><span style="color:#E1E4E8;">(oldCh.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">, newCh.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> commonLength; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 交集一对一辅导</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">patch</span><span style="color:#E1E4E8;">(oldCh[i], newCh[i], </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">rest);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldCh.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> newCh.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 差集旧多新少；删除一批旧的</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">unmountChildren</span><span style="color:#E1E4E8;">(oldCh.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(commonLength), </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">rest);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 差集旧少新多；添加一批新的</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">mountChildren</span><span style="color:#E1E4E8;">(newCh.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(commonLength), </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">rest);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 伪代码</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">patchUnkeyedChildren</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">oldCh</span><span style="color:#24292E;">, </span><span style="color:#E36209;">newCh</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#E36209;">rest</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    oldCh </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldCh </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> [];</span></span>
<span class="line"><span style="color:#24292E;">    newCh </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newCh </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> [];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">commonLength</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">min</span><span style="color:#24292E;">(oldCh.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">, newCh.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> commonLength; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 交集一对一辅导</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">patch</span><span style="color:#24292E;">(oldCh[i], newCh[i], </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">rest);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCh.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> newCh.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 差集旧多新少；删除一批旧的</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">unmountChildren</span><span style="color:#24292E;">(oldCh.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">(commonLength), </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">rest);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 差集旧少新多；添加一批新的</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">mountChildren</span><span style="color:#24292E;">(newCh.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">(commonLength), </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">rest);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></details><h2 id="有-key-子序列-diff" tabindex="-1">有 key 子序列 diff <a class="header-anchor" href="#有-key-子序列-diff" aria-label="Permalink to &quot;有 key 子序列 diff&quot;">​</a></h2><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// prettier-ignore</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 五种情况处理：</span></span>
<span class="line"><span style="color:#6A737D;"> * 1. 起始位置节点类型相同。</span></span>
<span class="line"><span style="color:#6A737D;"> * 2. 结束位置节点类型相同。</span></span>
<span class="line"><span style="color:#6A737D;"> * 3. 相同部分处理完，有新增节点。</span></span>
<span class="line"><span style="color:#6A737D;"> * 4. 相同部分处理完，有旧节点需要卸载。</span></span>
<span class="line"><span style="color:#6A737D;"> * 5. 首尾相同，但中间部分存在可复用乱序节点.</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">patchKeyedChildren</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">c1</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">[], </span><span style="color:#6A737D;">// 旧虚拟DOM</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">c2</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNodeArrayChildren</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 新虚拟DOM</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">container</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RendererElement</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">parentAnchor</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RendererNode</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">parentComponent</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ComponentInternalInstance</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">parentSuspense</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SuspenseBoundary</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">isSVG</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">boolean</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">slotScopeIds</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">[] </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">optimized</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">boolean</span></span>
<span class="line"><span style="color:#E1E4E8;">  ) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> l2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c2.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 新节点个数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 起始位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> e1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c1.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 旧后</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> e2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l2 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 新后</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 1：起始位置节点类型相同</span></span>
<span class="line"><span style="color:#6A737D;">     * 对比：新前--旧前</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[(a b) c]</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[(a b) d e]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：相同 =&gt; 为旧节点打补丁</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e1 </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      c2[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> optimized </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cloneIfMounted</span><span style="color:#E1E4E8;">(c2[i] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">normalizeVNode</span><span style="color:#E1E4E8;">(c2[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">n1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c1[i]</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">n2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c2[i]</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isSameVNodeType</span><span style="color:#E1E4E8;">(n1, n2)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">patch</span><span style="color:#E1E4E8;">(n1, n2, container, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      i</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 2：结束位置节点类型相同</span></span>
<span class="line"><span style="color:#6A737D;">     * 对比：新后--旧后</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[a (b c)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[d e (b c)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：相同 =&gt; 为旧节点打补丁</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e1 </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      c2[e2] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> optimized </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cloneIfMounted</span><span style="color:#E1E4E8;">(c2[e2] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">normalizeVNode</span><span style="color:#E1E4E8;">(c2[e2])</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">n1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c1[e1]</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">n2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c2[e2]</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isSameVNodeType</span><span style="color:#E1E4E8;">(n1, n2)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">patch</span><span style="color:#E1E4E8;">( n1, n2, container, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      e1</span><span style="color:#F97583;">--</span></span>
<span class="line"><span style="color:#E1E4E8;">      e2</span><span style="color:#F97583;">--</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 3：相同部分处理完，有新增节点。</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[(b c)]         old[(b c)]    </span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[e (b c)]       new[(b c) a]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：(i &gt; e1 &amp;&amp; i &lt;= e2) =&gt; 新增节点</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> e1) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nextPos</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e2 </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">anchor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextPos </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> l2 </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> (c2[nextPos] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">).el </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> parentAnchor</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          c2[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> optimized </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cloneIfMounted</span><span style="color:#E1E4E8;">(c2[i] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">normalizeVNode</span><span style="color:#E1E4E8;">(c2[i])</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">patch</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, c2[i], container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#E1E4E8;">          i</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 4. 相同部分处理完，有旧节点需要卸载。</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[a (b c)]     old[(b c) a]    </span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[(b c)]       new[(b c)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：(i &lt;= e1 &amp;&amp; i &gt; e2) =&gt; 删除多余的旧节点</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> e2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e1) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">unmount</span><span style="color:#E1E4E8;">(c1[i], parentComponent, parentSuspense, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        i</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 5. 首尾相同，但中间部分存在可复用乱序节点.</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[(b c) a e f (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[(b c) x e z (m n)] </span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：</span></span>
<span class="line"><span style="color:#6A737D;">     *      - 旧找新</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 有则补丁</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 无则删除</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 生成新节点匹配标识</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 生成乱序标识</span></span>
<span class="line"><span style="color:#6A737D;">     *      - 新旧结合构建最长稳定子序列，</span></span>
<span class="line"><span style="color:#6A737D;">     *      - 倒序遍历剩余新节点序列(用后一个修补的节点作为插入锚点)</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 新节点属于最长稳定子序列 =&gt; 则不动</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 新节点匹配标识不存在 =&gt; 则新增</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 新节点不属于最长稳定子序列且匹配 =&gt; 则移动</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 1:old  2:new</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">s1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#6A737D;">// 剩余旧序列开始下标</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">s2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#6A737D;">// 剩余新序列开始下标</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 剩余新子节点创建快速查找哈希表 { [key]: index }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">keyToNewIndexMap</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Map</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">symbol</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Map</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s2; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e2; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        c2[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> optimized </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cloneIfMounted</span><span style="color:#E1E4E8;">(c2[i] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">normalizeVNode</span><span style="color:#E1E4E8;">(c2[i])</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nextChild</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c2[i]</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextChild.key </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          keyToNewIndexMap.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(nextChild.key, i)</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> j </span><span style="color:#6A737D;">// 可复用新节点下标</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> patched </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 剩余旧节点匹配成功计数</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> toBePatched </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e2 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> s2 </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 剩余待匹配的新节点个数</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> moved </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 是否乱序</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> maxNewIndexSoFar </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 最大偏移，非递增则乱序</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 剩余待匹配的新节点的匹配标识，未匹配是0，匹配是匹配的旧节点下标</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> newIndexToOldIndexMap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Array</span><span style="color:#E1E4E8;">(toBePatched).</span><span style="color:#B392F0;">fill</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// [0, 0, 0]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">       * 1:old  2:new</span></span>
<span class="line"><span style="color:#6A737D;">       * 逻辑：遍历旧剩余序列</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：old[(b c) a e f (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：new[(b c) x e z (m n)] </span></span>
<span class="line"><span style="color:#6A737D;">       */</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s1; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e1; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">prevChild</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c1[i] </span><span style="color:#6A737D;">// 旧剩余</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (patched </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> toBePatched) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 如果 toBePatched 是 0 或者全匹配完成，那么其他旧剩余只能卸载</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">unmount</span><span style="color:#E1E4E8;">(prevChild, parentComponent, parentSuspense, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">continue</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> newIndex</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (prevChild.key </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 用旧剩余节点的 key 尝试获取 新剩余节点</span></span>
<span class="line"><span style="color:#E1E4E8;">          newIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> keyToNewIndexMap.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(prevChild.key)</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 尝试找一个同样没 key 但 type 相同的新剩余节点</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// newIndexToOldIndexMap[j - s2] === 0          新节点没有被匹配过</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// isSameVNodeType(prevChild, c2[j] as VNode)   仅 type 相同的可复用节点</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s2; j </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e2; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newIndexToOldIndexMap[j </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> s2] </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isSameVNodeType</span><span style="color:#E1E4E8;">(prevChild, c2[j] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                newIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newIndex </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 旧剩余节点始终匹配不了就删除</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">unmount</span><span style="color:#E1E4E8;">(prevChild, parentComponent, parentSuspense, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">           * 旧剩余节点匹配</span></span>
<span class="line"><span style="color:#6A737D;">           *    newIndex                指的是 旧剩余 匹配的 新剩余的下标</span></span>
<span class="line"><span style="color:#6A737D;">           *    newIndexToOldIndexMap   指的是 剩余新节点序列匹配标识 [0, 0,...]</span></span>
<span class="line"><span style="color:#6A737D;">           *    newIndex - s2           指的是 剩余偏移量</span></span>
<span class="line"><span style="color:#6A737D;">           *    maxNewIndexSoFar        初始值 0</span></span>
<span class="line"><span style="color:#6A737D;">           * </span></span>
<span class="line"><span style="color:#6A737D;">           * 迭代时可能 newIndex 依次是 5 3 7，从而发现乱序</span></span>
<span class="line"><span style="color:#6A737D;">           *    5 maxNewIndexSoFar = newIndex</span></span>
<span class="line"><span style="color:#6A737D;">           *    3 moved = true</span></span>
<span class="line"><span style="color:#6A737D;">           *    7 maxNewIndexSoFar = newIndex</span></span>
<span class="line"><span style="color:#6A737D;">           */</span></span>
<span class="line"><span style="color:#E1E4E8;">          newIndexToOldIndexMap[newIndex </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> s2] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 记录新节点匹配标识</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newIndex </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> maxNewIndexSoFar) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            maxNewIndexSoFar </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newIndex </span><span style="color:#6A737D;">// 记录最大偏移</span></span>
<span class="line"><span style="color:#E1E4E8;">          } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            moved </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 记录乱序标识</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">patch</span><span style="color:#E1E4E8;">(prevChild, c2[newIndex] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">, container, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#E1E4E8;">          patched</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 旧节点匹配计数记录</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">       * 上述阶段总结：</span></span>
<span class="line"><span style="color:#6A737D;">       * - 新剩余创建哈希表 hash</span></span>
<span class="line"><span style="color:#6A737D;">       * - 遍历旧剩余 while</span></span>
<span class="line"><span style="color:#6A737D;">       *    - 匹配新剩余 newIndex（key 不行 type相同也行）</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 记录剩余最大偏移 maxNewIndexSoFar</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 记录是否乱序    moved = 剩余最大偏移 === true</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 旧剩余打补丁    patch(old，new)</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 记录匹配个数    patched++</span></span>
<span class="line"><span style="color:#6A737D;">       *    - 无法匹配新剩余 !newIndex</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 销毁旧剩余 unmount(old)</span></span>
<span class="line"><span style="color:#6A737D;">       */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">       * 逻辑：乱序整理，仅当节点移动(乱序)时生成最长的稳定子序列</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：old[(b c) a e f h k o (m n)]  =&gt; old[(b c) e f h k (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：new[(b c) f x e z h k (m n)]  =&gt; new[(b c) f x e z h k (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">       * 最长的稳定子序列: e h k</span></span>
<span class="line"><span style="color:#6A737D;">       * 乱序：f</span></span>
<span class="line"><span style="color:#6A737D;">       */</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">increasingNewIndexSequence</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> moved </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getSequence</span><span style="color:#E1E4E8;">(newIndexToOldIndexMap) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">EMPTY_ARR</span></span>
<span class="line"><span style="color:#E1E4E8;">      j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> increasingNewIndexSequence.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 倒序遍历剩余新节点，以便我们可以使用后一个修补的节点作为锚点</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> toBePatched </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 下一个要处理的新后节点（新增或者移动）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nextIndex</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s2 </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> i</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nextChild</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c2[nextIndex] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 使用后一个修补的节点作为锚点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">anchor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextIndex </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> l2 </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> (c2[nextIndex </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">VNode</span><span style="color:#E1E4E8;">).el </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> parentAnchor</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">         * 举例：old[e f h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * 举例：new[f x e z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * </span></span>
<span class="line"><span style="color:#6A737D;">         * 最长的稳定子序列: e h k</span></span>
<span class="line"><span style="color:#6A737D;">         * 乱序：f</span></span>
<span class="line"><span style="color:#6A737D;">         * j：2（最长的稳定子序列长度 - 1）</span></span>
<span class="line"><span style="color:#6A737D;">         * </span></span>
<span class="line"><span style="color:#6A737D;">         * 倒序处理（以便我们可以使用后一个修补的节点作为锚点）</span></span>
<span class="line"><span style="color:#6A737D;">         * k 匹配且稳定     j--     i--                     old[e f h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * h 匹配且稳定     j--     i--                     old[e f h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * z 未匹配新增     patch   i--     anchor=h.el     old[e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * e 匹配且稳定     j--     i--                     old[e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * x 未匹配新增     patch   i--     anchor=e.el     old[x e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * f j&lt;0          move    i--     anchor=x.el     old[f x e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         */</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newIndexToOldIndexMap[i] </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">patch</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (moved) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> increasingNewIndexSequence[j]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">move</span><span style="color:#E1E4E8;">(nextChild, container, anchor, MoveType.</span><span style="color:#79B8FF;">REORDER</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">          } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            j</span><span style="color:#F97583;">--</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// prettier-ignore</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 五种情况处理：</span></span>
<span class="line"><span style="color:#6A737D;"> * 1. 起始位置节点类型相同。</span></span>
<span class="line"><span style="color:#6A737D;"> * 2. 结束位置节点类型相同。</span></span>
<span class="line"><span style="color:#6A737D;"> * 3. 相同部分处理完，有新增节点。</span></span>
<span class="line"><span style="color:#6A737D;"> * 4. 相同部分处理完，有旧节点需要卸载。</span></span>
<span class="line"><span style="color:#6A737D;"> * 5. 首尾相同，但中间部分存在可复用乱序节点.</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">patchKeyedChildren</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">c1</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">[], </span><span style="color:#6A737D;">// 旧虚拟DOM</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">c2</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNodeArrayChildren</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 新虚拟DOM</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">container</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RendererElement</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">parentAnchor</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RendererNode</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">parentComponent</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ComponentInternalInstance</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">parentSuspense</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SuspenseBoundary</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 父元素属性</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">isSVG</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">boolean</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">slotScopeIds</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">[] </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#E36209;">optimized</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">boolean</span></span>
<span class="line"><span style="color:#24292E;">  ) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> l2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c2.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 新节点个数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 起始位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> e1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c1.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 旧后</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> e2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l2 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 新后</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 1：起始位置节点类型相同</span></span>
<span class="line"><span style="color:#6A737D;">     * 对比：新前--旧前</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[(a b) c]</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[(a b) d e]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：相同 =&gt; 为旧节点打补丁</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e1 </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e2) {</span></span>
<span class="line"><span style="color:#24292E;">      c2[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> optimized </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cloneIfMounted</span><span style="color:#24292E;">(c2[i] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">normalizeVNode</span><span style="color:#24292E;">(c2[i]);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">n1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c1[i]</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">n2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c2[i]</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isSameVNodeType</span><span style="color:#24292E;">(n1, n2)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">patch</span><span style="color:#24292E;">(n1, n2, container, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#24292E;">      } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      i</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 2：结束位置节点类型相同</span></span>
<span class="line"><span style="color:#6A737D;">     * 对比：新后--旧后</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[a (b c)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[d e (b c)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：相同 =&gt; 为旧节点打补丁</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e1 </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e2) {</span></span>
<span class="line"><span style="color:#24292E;">      c2[e2] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> optimized </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cloneIfMounted</span><span style="color:#24292E;">(c2[e2] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">normalizeVNode</span><span style="color:#24292E;">(c2[e2])</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">n1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c1[e1]</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">n2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c2[e2]</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isSameVNodeType</span><span style="color:#24292E;">(n1, n2)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">patch</span><span style="color:#24292E;">( n1, n2, container, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#24292E;">      } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      e1</span><span style="color:#D73A49;">--</span></span>
<span class="line"><span style="color:#24292E;">      e2</span><span style="color:#D73A49;">--</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 3：相同部分处理完，有新增节点。</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[(b c)]         old[(b c)]    </span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[e (b c)]       new[(b c) a]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：(i &gt; e1 &amp;&amp; i &lt;= e2) =&gt; 新增节点</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> e1) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e2) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nextPos</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e2 </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">anchor</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextPos </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> l2 </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> (c2[nextPos] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">).el </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> parentAnchor</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e2) {</span></span>
<span class="line"><span style="color:#24292E;">          c2[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> optimized </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cloneIfMounted</span><span style="color:#24292E;">(c2[i] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">normalizeVNode</span><span style="color:#24292E;">(c2[i])</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">patch</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, c2[i], container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#24292E;">          i</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 4. 相同部分处理完，有旧节点需要卸载。</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[a (b c)]     old[(b c) a]    </span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[(b c)]       new[(b c)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：(i &lt;= e1 &amp;&amp; i &gt; e2) =&gt; 删除多余的旧节点</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> e2) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e1) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">unmount</span><span style="color:#24292E;">(c1[i], parentComponent, parentSuspense, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        i</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * 情况 5. 首尾相同，但中间部分存在可复用乱序节点.</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：old[(b c) a e f (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">     * 示例：new[(b c) x e z (m n)] </span></span>
<span class="line"><span style="color:#6A737D;">     * 处理：</span></span>
<span class="line"><span style="color:#6A737D;">     *      - 旧找新</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 有则补丁</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 无则删除</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 生成新节点匹配标识</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 生成乱序标识</span></span>
<span class="line"><span style="color:#6A737D;">     *      - 新旧结合构建最长稳定子序列，</span></span>
<span class="line"><span style="color:#6A737D;">     *      - 倒序遍历剩余新节点序列(用后一个修补的节点作为插入锚点)</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 新节点属于最长稳定子序列 =&gt; 则不动</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 新节点匹配标识不存在 =&gt; 则新增</span></span>
<span class="line"><span style="color:#6A737D;">     *          - 新节点不属于最长稳定子序列且匹配 =&gt; 则移动</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 1:old  2:new</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">s1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#6A737D;">// 剩余旧序列开始下标</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">s2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#6A737D;">// 剩余新序列开始下标</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 剩余新子节点创建快速查找哈希表 { [key]: index }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">keyToNewIndexMap</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Map</span><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">string</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">symbol</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Map</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s2; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e2; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        c2[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> optimized </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cloneIfMounted</span><span style="color:#24292E;">(c2[i] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">normalizeVNode</span><span style="color:#24292E;">(c2[i])</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nextChild</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c2[i]</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextChild.key </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          keyToNewIndexMap.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(nextChild.key, i)</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> j </span><span style="color:#6A737D;">// 可复用新节点下标</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> patched </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 剩余旧节点匹配成功计数</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> toBePatched </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e2 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> s2 </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;  </span><span style="color:#6A737D;">// 剩余待匹配的新节点个数</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> moved </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 是否乱序</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> maxNewIndexSoFar </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 最大偏移，非递增则乱序</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 剩余待匹配的新节点的匹配标识，未匹配是0，匹配是匹配的旧节点下标</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> newIndexToOldIndexMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Array</span><span style="color:#24292E;">(toBePatched).</span><span style="color:#6F42C1;">fill</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// [0, 0, 0]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">       * 1:old  2:new</span></span>
<span class="line"><span style="color:#6A737D;">       * 逻辑：遍历旧剩余序列</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：old[(b c) a e f (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：new[(b c) x e z (m n)] </span></span>
<span class="line"><span style="color:#6A737D;">       */</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s1; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e1; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">prevChild</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c1[i] </span><span style="color:#6A737D;">// 旧剩余</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (patched </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> toBePatched) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 如果 toBePatched 是 0 或者全匹配完成，那么其他旧剩余只能卸载</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">unmount</span><span style="color:#24292E;">(prevChild, parentComponent, parentSuspense, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">continue</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> newIndex</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (prevChild.key </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 用旧剩余节点的 key 尝试获取 新剩余节点</span></span>
<span class="line"><span style="color:#24292E;">          newIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> keyToNewIndexMap.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(prevChild.key)</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 尝试找一个同样没 key 但 type 相同的新剩余节点</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// newIndexToOldIndexMap[j - s2] === 0          新节点没有被匹配过</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// isSameVNodeType(prevChild, c2[j] as VNode)   仅 type 相同的可复用节点</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s2; j </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e2; j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newIndexToOldIndexMap[j </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> s2] </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isSameVNodeType</span><span style="color:#24292E;">(prevChild, c2[j] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">                newIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newIndex </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 旧剩余节点始终匹配不了就删除</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">unmount</span><span style="color:#24292E;">(prevChild, parentComponent, parentSuspense, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">           * 旧剩余节点匹配</span></span>
<span class="line"><span style="color:#6A737D;">           *    newIndex                指的是 旧剩余 匹配的 新剩余的下标</span></span>
<span class="line"><span style="color:#6A737D;">           *    newIndexToOldIndexMap   指的是 剩余新节点序列匹配标识 [0, 0,...]</span></span>
<span class="line"><span style="color:#6A737D;">           *    newIndex - s2           指的是 剩余偏移量</span></span>
<span class="line"><span style="color:#6A737D;">           *    maxNewIndexSoFar        初始值 0</span></span>
<span class="line"><span style="color:#6A737D;">           * </span></span>
<span class="line"><span style="color:#6A737D;">           * 迭代时可能 newIndex 依次是 5 3 7，从而发现乱序</span></span>
<span class="line"><span style="color:#6A737D;">           *    5 maxNewIndexSoFar = newIndex</span></span>
<span class="line"><span style="color:#6A737D;">           *    3 moved = true</span></span>
<span class="line"><span style="color:#6A737D;">           *    7 maxNewIndexSoFar = newIndex</span></span>
<span class="line"><span style="color:#6A737D;">           */</span></span>
<span class="line"><span style="color:#24292E;">          newIndexToOldIndexMap[newIndex </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> s2] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 记录新节点匹配标识</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newIndex </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> maxNewIndexSoFar) {</span></span>
<span class="line"><span style="color:#24292E;">            maxNewIndexSoFar </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newIndex </span><span style="color:#6A737D;">// 记录最大偏移</span></span>
<span class="line"><span style="color:#24292E;">          } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            moved </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 记录乱序标识</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">patch</span><span style="color:#24292E;">(prevChild, c2[newIndex] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">, container, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#24292E;">          patched</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 旧节点匹配计数记录</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">       * 上述阶段总结：</span></span>
<span class="line"><span style="color:#6A737D;">       * - 新剩余创建哈希表 hash</span></span>
<span class="line"><span style="color:#6A737D;">       * - 遍历旧剩余 while</span></span>
<span class="line"><span style="color:#6A737D;">       *    - 匹配新剩余 newIndex（key 不行 type相同也行）</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 记录剩余最大偏移 maxNewIndexSoFar</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 记录是否乱序    moved = 剩余最大偏移 === true</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 旧剩余打补丁    patch(old，new)</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 记录匹配个数    patched++</span></span>
<span class="line"><span style="color:#6A737D;">       *    - 无法匹配新剩余 !newIndex</span></span>
<span class="line"><span style="color:#6A737D;">       *        - 销毁旧剩余 unmount(old)</span></span>
<span class="line"><span style="color:#6A737D;">       */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">       * 逻辑：乱序整理，仅当节点移动(乱序)时生成最长的稳定子序列</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：old[(b c) a e f h k o (m n)]  =&gt; old[(b c) e f h k (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">       * 示例：new[(b c) f x e z h k (m n)]  =&gt; new[(b c) f x e z h k (m n)]</span></span>
<span class="line"><span style="color:#6A737D;">       * 最长的稳定子序列: e h k</span></span>
<span class="line"><span style="color:#6A737D;">       * 乱序：f</span></span>
<span class="line"><span style="color:#6A737D;">       */</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">increasingNewIndexSequence</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> moved </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getSequence</span><span style="color:#24292E;">(newIndexToOldIndexMap) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">EMPTY_ARR</span></span>
<span class="line"><span style="color:#24292E;">      j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> increasingNewIndexSequence.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 倒序遍历剩余新节点，以便我们可以使用后一个修补的节点作为锚点</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> toBePatched </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 下一个要处理的新后节点（新增或者移动）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nextIndex</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s2 </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> i</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nextChild</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c2[nextIndex] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 使用后一个修补的节点作为锚点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">anchor</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextIndex </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> l2 </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> (c2[nextIndex </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">VNode</span><span style="color:#24292E;">).el </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> parentAnchor</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">         * 举例：old[e f h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * 举例：new[f x e z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * </span></span>
<span class="line"><span style="color:#6A737D;">         * 最长的稳定子序列: e h k</span></span>
<span class="line"><span style="color:#6A737D;">         * 乱序：f</span></span>
<span class="line"><span style="color:#6A737D;">         * j：2（最长的稳定子序列长度 - 1）</span></span>
<span class="line"><span style="color:#6A737D;">         * </span></span>
<span class="line"><span style="color:#6A737D;">         * 倒序处理（以便我们可以使用后一个修补的节点作为锚点）</span></span>
<span class="line"><span style="color:#6A737D;">         * k 匹配且稳定     j--     i--                     old[e f h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * h 匹配且稳定     j--     i--                     old[e f h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * z 未匹配新增     patch   i--     anchor=h.el     old[e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * e 匹配且稳定     j--     i--                     old[e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * x 未匹配新增     patch   i--     anchor=e.el     old[x e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         * f j&lt;0          move    i--     anchor=x.el     old[f x e f z h k]</span></span>
<span class="line"><span style="color:#6A737D;">         */</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newIndexToOldIndexMap[i] </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">patch</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (moved) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> increasingNewIndexSequence[j]) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">move</span><span style="color:#24292E;">(nextChild, container, anchor, MoveType.</span><span style="color:#005CC5;">REORDER</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">          } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            j</span><span style="color:#D73A49;">--</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br><span class="line-number">189</span><br><span class="line-number">190</span><br><span class="line-number">191</span><br><span class="line-number">192</span><br><span class="line-number">193</span><br><span class="line-number">194</span><br><span class="line-number">195</span><br><span class="line-number">196</span><br><span class="line-number">197</span><br><span class="line-number">198</span><br><span class="line-number">199</span><br><span class="line-number">200</span><br><span class="line-number">201</span><br><span class="line-number">202</span><br><span class="line-number">203</span><br><span class="line-number">204</span><br><span class="line-number">205</span><br><span class="line-number">206</span><br><span class="line-number">207</span><br><span class="line-number">208</span><br><span class="line-number">209</span><br><span class="line-number">210</span><br><span class="line-number">211</span><br><span class="line-number">212</span><br><span class="line-number">213</span><br><span class="line-number">214</span><br><span class="line-number">215</span><br><span class="line-number">216</span><br><span class="line-number">217</span><br><span class="line-number">218</span><br><span class="line-number">219</span><br><span class="line-number">220</span><br><span class="line-number">221</span><br><span class="line-number">222</span><br><span class="line-number">223</span><br><span class="line-number">224</span><br><span class="line-number">225</span><br><span class="line-number">226</span><br><span class="line-number">227</span><br><span class="line-number">228</span><br><span class="line-number">229</span><br><span class="line-number">230</span><br><span class="line-number">231</span><br><span class="line-number">232</span><br><span class="line-number">233</span><br><span class="line-number">234</span><br><span class="line-number">235</span><br><span class="line-number">236</span><br><span class="line-number">237</span><br><span class="line-number">238</span><br><span class="line-number">239</span><br><span class="line-number">240</span><br><span class="line-number">241</span><br><span class="line-number">242</span><br><span class="line-number">243</span><br><span class="line-number">244</span><br><span class="line-number">245</span><br><span class="line-number">246</span><br><span class="line-number">247</span><br><span class="line-number">248</span><br><span class="line-number">249</span><br><span class="line-number">250</span><br><span class="line-number">251</span><br><span class="line-number">252</span><br><span class="line-number">253</span><br><span class="line-number">254</span><br></div></div>`,8),e=[o];function c(r,t,y,E,i,b){return a(),n("div",null,e)}const F=s(p,[["render",c]]);export{D as __pageData,F as default};
